<?xml version="1.0" encoding="utf-8"?>
<mx:VBox
	xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:flexlib="flexlib.containers.*"
    backgroundColor="white"
    initialize="loadFeatures()">

<mx:ViewStack id="sidebar" width="100%" height="100%" creationPolicy="all">
  <mx:VBox id="dndPanel" width="100%" height="100%">
    <!-- FIXME the panel text is repeated below for mouseOut -->
    <mx:Text id="dndPanelText" text="Drag and Drop Points of Interest" />
    <mx:TileList id="poiGrid" dataProvider="{MapFeatures.getInstance().pois}" width="100%" height="100%">
      <mx:itemRenderer>
        <mx:Component>
          <mx:VBox mouseOver="parentDocument.dndPanelText.text = data.name"
                   mouseOut="parentDocument.dndPanelText.text = 'Drag and Drop Points of Interest'">
            <mx:Script><![CDATA[
              import mx.events.DragEvent;
              import mx.managers.DragManager;
              import mx.core.DragSource;
                  
              private function dragPOI(event:MouseEvent, tags:Array):void {
                  // Get the drag initiator component from the event object.
                  var dragInitiator:Image = event.currentTarget as Image;
                  var dragSource:DragSource = new DragSource();
                  dragSource.addData(tags, 'tags');
                  
                  var dragProxy:Image = new Image();
                  dragProxy.source = dragInitiator.source;
                  dragProxy.width = dragInitiator.width;   // must set width and height explicitly
                  dragProxy.height = dragInitiator.height; // for non-embedded images
                  DragManager.doDrag(dragInitiator, dragSource, event, dragProxy);
              }
            ]]></mx:Script>
            <mx:Image id="foo" source="{data.image}" height="25" width="25" mouseMove="dragPOI(event, data.tags)" toolTip="{data.name}" />
          </mx:VBox>
        </mx:Component>
      </mx:itemRenderer>
    </mx:TileList>
  </mx:VBox>
  
  <mx:VBox id="tagsPanel" width="100%" height="100%">
    <mx:ViewStack id="stack" width="100%" height="100%">
      <mx:VBox width="100%" height="100%" label="Simple">
        <mx:HBox borderStyle="inset" verticalAlign="middle" width="100%" paddingLeft="3" id="iconContainer">
            <mx:Image id="iconImage"/>
            <mx:VBox width="100%" verticalGap="1">
              <mx:PopUpButton id="popupChange" creationComplete="initFeatureBox()" openAlways="true" width="100%"/>
              <mx:Text condenseWhite="true" width="100%" id="iconText"/>
            </mx:VBox>
            <mx:LinkButton label="?" click="openDescription()" id="helpLabel"/>
        </mx:HBox>
        <flexlib:SuperTabNavigator id="editorStack" width="100%" height="100%" paddingLeft="2" paddingRight="2"
            allowTabSqueezing="false" minTabWidth="10" closePolicy="close_never"
            scrollSpeed="20" change="ensureEditorsPopulated(IndexChangedEvent(event).relatedObject as VBox)"/>
      </mx:VBox>

      <mx:VBox width="100%" height="100%" label="Advanced" initialize="checkAdvanced()" verticalGap="1">
        <mx:Label id="advancedID">
          <mx:htmlText><![CDATA[<i>No Selection</i>]]></mx:htmlText>
        </mx:Label>

        <mx:DataGrid editable="true" width="100%" height="75%" id="advancedTagGrid">
                <mx:columns>
                    <mx:DataGridColumn editable="true" dataField="key" headerText="Key"/>
                    <mx:DataGridColumn editable="true" dataField="value" headerText="Value"/>
                </mx:columns>
        </mx:DataGrid>

        <mx:HBox horizontalAlign="right" width="100%">
          <mx:LinkButton label="Delete" click="removeTag()" enabled="{advancedTagGrid.selectedItem != null? true : false}"/>
          <mx:LinkButton label="Add" click="addNewTag()"/>
        </mx:HBox>
        
        <mx:DataGrid editable="true" width="100%" height="25%" id="relationsGrid"
            doubleClickEnabled="true"
            itemDoubleClick="editRelation(relationsGrid.selectedItem.id)">
            <mx:columns>
                <mx:DataGridColumn editable="false" dataField="description" headerText="Relation"/>
                <mx:DataGridColumn editable="false" dataField="id_idx" headerText="ID"/>
                <mx:DataGridColumn editable="true" dataField="role" headerText="Role"/>
            </mx:columns>
        </mx:DataGrid>

        <mx:HBox horizontalAlign="right" width="100%">
          <mx:LinkButton label="Remove from" click="removeFromRelation(relationsGrid.selectedItem.id, relationsGrid.selectedItem.index)" 
                          enabled="{relationsGrid.selectedItem != null? true : false}"/>
          <mx:LinkButton label="Add to" click="addToRelation()"/>
        </mx:HBox>

      </mx:VBox>

      <mx:VBox width="100%" height="100%" label="Members" id="membersVBox" initialize="checkMembers()" verticalGap="1">
        <mx:Label id="membersText" text="Relation Members"/>
        <mx:DataGrid editable="true" width="100%" height="100%" id="membersGrid"
                      dragEnabled="true" dragMoveEnabled="true" dropEnabled="true">
          <mx:columns>
            <mx:DataGridColumn editable="false" dataField="type" headerText="Type"/>
            <mx:DataGridColumn editable="false" dataField="id" headerText="ID"/>
            <mx:DataGridColumn editable="true" dataField="role" headerText="Role"/>
          </mx:columns>
        </mx:DataGrid>
      </mx:VBox>
      
      </mx:ViewStack>
    <mx:LinkBar dataProvider="{stack}"/>
  </mx:VBox>
</mx:ViewStack>

  <mx:Script><![CDATA[
      import net.systemeD.halcyon.connection.*;
      import net.systemeD.potlatch2.mapfeatures.*;

      import mx.collections.*;
      import mx.containers.*;
      import mx.events.*;
      import mx.core.*;
      import mx.managers.PopUpManager;
      import flash.geom.Point;
      import flash.net.*;
      import mx.events.DragEvent;
      import mx.managers.DragManager;
      import mx.core.DragSource;
      
      private var mapFeatures:MapFeatures;
      private var selectedEntity:Entity;
      private var tagDataProvider:ArrayCollection;
      private var tw:CategorySelector = null;
      private var feature:Feature = null;

      public function setEntity(entity:Entity):void {
          if ( selectedEntity != entity ) {
              if ( selectedEntity != null )
                  selectedEntity.removeEventListener(Connection.TAG_CHANGED, tagChanged);
              selectedEntity = entity;
              if ( selectedEntity != null )
                  selectedEntity.addEventListener(Connection.TAG_CHANGED, tagChanged);
          }

          if ( advancedID != null )
              setupAdvanced(entity);
          if (entity is Relation) {
              stack.addChild(membersVBox);
          }
          refreshFeatureIcon(); 
          
          if (selectedEntity == null) {
            sidebar.selectedChild = dndPanel;
          } else {
            sidebar.selectedChild = tagsPanel;
          }
      }

      private function refreshFeatureIcon():void {
          var oldFeature:Feature = feature;
          feature = selectedEntity == null ? null : mapFeatures.findMatchingFeature(selectedEntity);
          if ( feature != oldFeature ) {
              if ( oldFeature != null )
                  oldFeature.removeEventListener("imageChanged", featureImageChanged);
              if ( feature != null )
                  feature.addEventListener("imageChanged", featureImageChanged);
              initialiseEditors();
          }

          if ( feature != null )
              setFeatureIcon(selectedEntity, feature);
          else
              blankFeatureIcon(selectedEntity);
      }

      private function featureImageChanged(event:Event):void {
          setFeatureIcon(selectedEntity, feature);
      }
      
      private function setFeatureIcon(entity:Entity, feature:Feature):void {
          //blankFeatureIcon(entity);
          
          iconImage.source = feature.image;

          var txt:String = feature.htmlDetails(entity);
          iconText.htmlText = txt;
          popupChange.label = feature.name;
          setLimitTypes(entity);
          tw.setSelectedFeature(feature);
          helpLabel.visible = feature.hasHelpURL();
      }
      
      private function setLimitTypes(entity:Entity):void {
          var type:String = null;
          if ( entity is Node )
              type = "point";
          else if ( entity is Way )
              type = Way(entity).isArea() ? "area" : "line";
          else if ( entity is Relation )
              type = "relation";
          tw.setLimitTypes(type);
      }

      private function blankFeatureIcon(entity:Entity):void {
          iconImage.source = null;
		  if (entity == null) { 
			iconText.htmlText = "<i>Nothing selected</i>";
		  } else if (entity.hasTags()) {
			iconText.htmlText = "<b>Not recognised</b><br/>Try looking at the tags under the advanced properties";
		  } else {
			iconText.htmlText = "<b>No tags set</b><br/>Use the menu above to say what this "+entity.getType()+" is";
          }
          popupChange.label = "unknown";
          setLimitTypes(entity);
          tw.setSelectedFeature(null);
          helpLabel.visible = false;
      }

      private var tabComponents:Object = {};
      
      private function initialiseEditors():void {
          editorStack.removeAllChildren();
          if ( selectedEntity == null || feature == null )
              return;
          
          var editorBox:VBox = createEditorBox();
          editorBox.label = "Basic";
          editorStack.addChild(editorBox);
          
          var tabs:Object = {};
          tabComponents = {};
          
          for each (var factory:EditorFactory in feature.editors) {
              if ( factory.presence.isEditorPresent(factory, selectedEntity, null) ) {
                  var editor:DisplayObject = factory.createEditorInstance(selectedEntity);
                  if ( editor != null )
                      editorBox.addChild(editor);
              }
              var category:String = factory.category;
              var tab:VBox = tabs[category];
              if ( tab == null ) {
                  tab = createEditorBox();
                  tab.label = category;
                  editorStack.addChild(tab);
                  tabs[category] = tab;
                  tabComponents[tab] = [];
              }
              var catEditor:DisplayObject = factory.createEditorInstance(selectedEntity);
              if ( catEditor != null )
                  tabComponents[tab].push(catEditor);
              //    tab.addChild(catEditor);
          }
      }
      
      private function createEditorBox():VBox {
          var box:VBox = new VBox();
          box.percentWidth = 100;
          box.percentHeight = 100;
          return box;
      }

      private function ensureEditorsPopulated(tab:VBox):void {
          var components:Array = tabComponents[tab];
          if ( components == null || tab == null || tab.numChildren >= components.length )
              return;
          for each (var component:DisplayObject in components ) {
              tab.addChild(component);
          }
      }
      
      private function checkAdvanced():void {
          if ( selectedEntity != null )
             setupAdvanced(selectedEntity);
      }

      private var listeningToRelations:Array = [];
      
      private function setupAdvanced(entity:Entity):void {
          if ( tagDataProvider == null ) {
              tagDataProvider = new ArrayCollection();
              advancedTagGrid.dataProvider = tagDataProvider;
          }

          tagDataProvider.removeAll();
          
          if ( entity == null ) {
              advancedID.htmlText = "";
          } else {
              var entityText:String = "xx";
              if ( entity is Node ) entityText = "Node";
              else if ( entity is Way ) entityText = "Way";
              else if ( entity is Relation ) entityText = "Relation";
              advancedID.htmlText = entityText+": <b>"+entity.id+"</b>";

              var tags:Array = entity.getTagArray();
              tags.sortOn("key");
              for each(var tag:Tag in tags)
                  tagDataProvider.addItem(tag);
          }
                    
          removeRelationListeners();
          if ( selectedEntity != null ) {
              selectedEntity.removeEventListener(Connection.ADDED_TO_RELATION, addedToRelation);
              selectedEntity.removeEventListener(Connection.REMOVED_FROM_RELATION, removedFromRelation);
          }
          
          if ( entity == null ) {
              relationsGrid.dataProvider = null;
          } else {
              resetRelationsGrid(entity);
              entity.addEventListener(Connection.ADDED_TO_RELATION, addedToRelation);
              entity.addEventListener(Connection.REMOVED_FROM_RELATION, removedFromRelation);
          }
      }
      
      private function addedToRelation(event:RelationMemberEvent):void {
         resetRelationsGrid(selectedEntity);
      }

      private function removedFromRelation(event:RelationMemberEvent):void {
         resetRelationsGrid(selectedEntity);
      }

      private function removeRelationListeners():void {
          for each( var rel:Relation in listeningToRelations ) {
              rel.removeEventListener(Connection.TAG_CHANGED, relationTagChanged);
              rel.removeEventListener(Connection.RELATION_MEMBER_ADDED, entityRelationMemberChanged);
              rel.removeEventListener(Connection.RELATION_MEMBER_REMOVED, entityRelationMemberChanged);
          }
          listeningToRelations = [];
          relationsGrid.removeEventListener(DataGridEvent.ITEM_EDIT_END, relationRoleChanged);
      }
            
      private function resetRelationsGrid(entity:Entity):void {
          removeRelationListeners();
          var relations:Array = [];
          for each( var rel:Relation in entity.parentRelations ) {
              for each( var memberIndex:int in rel.findEntityMemberIndexes(entity)) {
                  var props:Object = {};
                  props["relation"] = rel;
                  props["id"] = rel.id;
                  props["index"] = memberIndex;
                  props["role"] = rel.getMember(memberIndex).role;
                  props["description"] = rel.getDescription();
                  props["id_idx"] = rel.id + "/"+memberIndex;

                  relations.push(props);
              }
              
              rel.addEventListener(Connection.TAG_CHANGED, relationTagChanged);
              rel.addEventListener(Connection.RELATION_MEMBER_ADDED, entityRelationMemberChanged);
              rel.addEventListener(Connection.RELATION_MEMBER_REMOVED, entityRelationMemberChanged);
              listeningToRelations.push(rel);
          }
          relationsGrid.dataProvider = relations;
          relationsGrid.addEventListener(DataGridEvent.ITEM_EDIT_END, relationRoleChanged, false, -100);
      }
      
      private function relationRoleChanged(event:DataGridEvent):void {
		if (event.dataField != 'role') { return; }	// shouldn't really happen

		var relations:Array=event.currentTarget.dataProvider.toArray();
		var props:Object=relations[event.rowIndex];

		var relation:Relation=props['relation'];
		var index:uint=props['index'];
		var newRole:String=event.itemRenderer.data['role'];

		relation.setMember(index, new RelationMember(selectedEntity,newRole));
      }

      private function relationTagChanged(event:TagEvent):void {
          resetRelationsGrid(selectedEntity);
      }

      private function entityRelationMemberChanged(event:RelationMemberEvent):void {
          resetRelationsGrid(selectedEntity);
      }
      
      private function checkMembers():void {
          if (selectedEntity is Relation) {
            setupMembers(selectedEntity as Relation);
          }
      }
      
      private function setupMembers(rel:Relation):void {
          var members:Array = [];
          for (var i:int=0 ; i<rel.length; i++) {
            var props:Object = {};
            var member:RelationMember = rel.getMember(i);
            props["id"] = member.entity.id;
            props["type"] = member.entity.getType();
            props["role"] = member.role;
            
            members.push(props);
          }
          membersGrid.dataProvider = members;
          membersGrid.dataProvider.addEventListener('collectionChange', membersChange); 
      }
      
      private function membersChange(event:Event):void {
          // Dropping all the members and re-adding them isn't exactly optimal
          // but is at least robust for any kind of change.
          // Figuring out a better way is someone else's FIXME
          
          var conn:Connection = Connection.getConnectionInstance();
          var rel:Relation = selectedEntity as Relation
          
          // drop members
          trace("Dropping "+rel.length+" members");
          for (var i:int=rel.length-1 ; i>=0; i--) {
            rel.removeMemberByIndex(i);
          }
          
          // add members in new order
          for each(var memberObject:Object in membersGrid.dataProvider) {
            var e:Entity;
            var id:Number = memberObject.id;
            if(memberObject.type == 'node') {
              e = conn.getNode(id);
            } else if (memberObject.type == 'way') {
              e = conn.getWay(id);
            } else if (memberObject.type == 'relation') {
              e = conn.getRelation(id);
            }
            rel.appendMember(new RelationMember(e, memberObject.role));
            trace("added member "+memberObject.type+" "+id+" in role "+memberObject.role);
          }
          trace("complete: relation "+rel.id+" now has "+rel.length+" members");
      }
      
      private function editRelation(id:Number):void {
          var panel:RelationEditorPanel = RelationEditorPanel(
              PopUpManager.createPopUp(Application(Application.application), RelationEditorPanel, true));
          panel.setRelation(Connection.getConnectionInstance().getRelation(id));
          PopUpManager.centerPopUp(panel);
      }
      
      private function tagChanged(event:TagEvent):void {
          refreshFeatureIcon();
          
          if ( tagDataProvider != null ) {
              // check to see if the key is already in our list
              var exists:Boolean = false;
              var tag:Tag = null;
              var i:uint;
              for ( i = 0; i < tagDataProvider.length && !exists; i++ ) {
                  tag = Tag(tagDataProvider.getItemAt(i));
                  exists = tag.key == event.key;
              }
              if ( !exists ) {
                  tag = new Tag(selectedEntity, event.key, event.newValue);
                  tagDataProvider.addItem(tag);
                  tagDataProvider.refresh();
              } else {
                  if ( event.newValue == null ) {
                      tagDataProvider.removeItemAt(i-1);
                      tagDataProvider.refresh();
                  } else {
                      tagDataProvider.itemUpdated(tag, "value");
                  }
              }
          }
      }

      public function loadFeatures():void {
          mapFeatures = MapFeatures.getInstance();
          stack.removeChild(membersVBox); // remove by default, will be added if relation
      }

      public function openDescription():void {
          trace("open description here");
          if ( feature != null && feature.hasHelpURL() )
              navigateToURL(new URLRequest(feature.helpURL), "potlatch_help");
      }

      public function addNewTag():void {
          var newKey:String = "(new tag)";
          var newTag:Tag = new Tag(selectedEntity, newKey, "(new value)");
          tagDataProvider.addItem(newTag);
          advancedTagGrid.editedItemPosition = {rowIndex: tagDataProvider.getItemIndex(newTag), columnIndex: 0};
      }

      public function removeTag():void {
          var k:String = advancedTagGrid.selectedItem.key;
          selectedEntity.setTag(k, null, MainUndoStack.getGlobalStack().addAction);
      }
      
      public function addToRelation():void {
          new RelationSelectPanel().init(selectedEntity,new Object());
      }
      
      public function removeFromRelation(id:Number, index:int):void {
          Connection.getConnectionInstance().getRelation(id).removeMemberByIndex(index);
      }
      
      public function initFeatureBox():void {
          tw = new CategorySelector();
          tw.addEventListener("selectedType", changeFeatureType);
          popupChange.popUp = tw;
      }
      
      public function changeFeatureType(event:Event):void {
          if ( selectedEntity == null )
              return;

          var newFeature:Feature = tw.selectedType;
          var undoStack:Function = MainUndoStack.getGlobalStack().addAction;
          var action:CompositeUndoableAction = new CompositeUndoableAction(
                  "Set "+selectedEntity.getType()+" "+selectedEntity.id+" to "+newFeature.name);

          // remove tags from the current feature
          if ( feature != null ) {
              for each( var oldtag:Object in feature.tags ) {
                  selectedEntity.setTag(oldtag["k"], null, action.push);
              }
          }
          
          // set tags for new feature
          if ( newFeature != null ) {
              for each( var newtag:Object in newFeature.tags ) {
                  selectedEntity.setTag(newtag["k"], newtag["v"], action.push);
              }
          }
          
          undoStack(action);
          popupChange.close();
      }
      
      private function dragPOI(event:MouseEvent, tags:Array):void {
          // Get the drag initiator component from the event object.
          var dragInitiator:Image = event.currentTarget as Image;
          var dragSource:DragSource = new DragSource();
          dragSource.addData(tags, 'tags');
          
          var dragProxy:Image = new Image();
          dragProxy.source = event.currentTarget.source;
          
          DragManager.doDrag(dragInitiator, dragSource, event, dragProxy);
      }
  ]]></mx:Script>
</mx:VBox>

